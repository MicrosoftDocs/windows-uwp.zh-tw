---
title: 連接的儲存空間技術概觀
description: 深入了解連接的儲存體的內部運作。
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.date: 02/27/2018
ms.topic: article
keywords: xbox live、 xbox、 遊戲、 uwp、 windows 10、 xbox，連接的儲存體
ms.localizationpriority: medium
ms.openlocfilehash: 6eddd11a370b8dcadc5108fe00539c2c6d1d9d1a
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2019
ms.locfileid: "57624053"
---
# <a name="connected-storage"></a>連接的儲存空間

> [!NOTE]
> 這份文件原先是針對受管理夥伴 Xbox One 的開發人員編寫的。  Xbox One 的特定內容，例如本機和標題的儲存體的一些可以在 Windows 上的 UWP 忽略。  本文件中的 API 與概念性內容是仍然相關。  請連絡您的 Microsoft 代表 （如果適用） 的任何問題。

儲存體和 Xbox One 上的儲存模型是很多不同的 Xbox 360;Xbox One 具有更具彈性的應用程式模型，可支援快速切換，就會有多個同時的應用程式的應用程式和快速暫停和繼續的應用程式。 使用連接儲存體 API 會自動儲存的資料跨多個 Xbox One 的主控台，漫遊的使用者，同時也是可供離線使用。

本主題涵蓋：

-   Xbox One 上使用連接儲存體 API 來儲存遊戲和應用程式資料。
-   應用程式的設計的最佳做法會儲存系統，使它們與 Xbox One 的應用程式模型所提供的使用者體驗優點整合。
-   連接的儲存體系統如何最大化您的應用程式可以將資料儲存與速度
-   系統如何處理資料同步處理和資料衝突，從多個主控台而不需要應用程式 UI。
-   連接的儲存體復原模型，經過設計，所以應用程式一律會有自我一致的檢視，甚至是在中斷的網路連線或電源中斷的情況下的個別容器中儲存的資料。

> [!NOTE]
> 詞彙*應用程式*，因為使用這裡，是指任何在主控台中，包括遊戲上執行的應用程式。

## <a name="overview"></a>概觀

Xbox One 的應用程式模型可讓使用者使用多個應用程式，這表示您的應用程式，無法要求使用者等候關閉主控台，或移到另一個應用程式之前儲存的資料。 Xbox One 的使用者也會喜歡讓他們在主控台，讓每個 Xbox One 主控台覺得自己主控台自動漫遊的資料。 Xbox One 的平台提供連線儲存體 API，以協助您滿足這些需求的應用程式。

連接的儲存體系統，可讓應用程式將資料儲存成一或多個*blob*中*容器*。 當應用程式儲存資料時，快速從複製獨佔的磁碟分割到共用的資料分割，以便在磁碟上儲存資料，以及上傳到 Xbox Live 的標題儲存體的工作可以處理您的應用程式的存留期間之外。

當您的應用程式會要求特定的使用者資料從連接的儲存體系統時，系統會自動檢查與更新資料的雲端，並通知使用者，如果他們需要等候下載的資料。 系統也會要求使用者選擇 衝突的資料，在某些情況下，例如當使用者扮演了非常離線在多個主控台中，或上傳另一個主控台時儲存該使用者的資料。

您的應用程式也會有專用的但功能受限的雲端儲存空間量的每位使用者，因此使用者不需要硬選擇永久刪除資料，從一個應用程式以挪出空間供另一個應用程式儲存。 沒有，不過，數量有限的儲存空間用於快取儲存在本機，因此系統會提供使用者體驗來釋出本機快取空間 Xbox One 的硬碟機上。 使用者可以控制哪些本機快取;它們永遠不會喪失存取權熱身離線時，他們想知道的資料。 連接的儲存體系統也會允許少量使用者無關的資料儲存在本機應用程式。 這個每台電腦的資料不會漫遊，以及未上傳至雲端。

Xbox One 連接的儲存體系統會處理系統電源管理暫止寫入硬碟和上的傳至雲端會自動處理 — 若要顯示 UI 的項目不需要說: 「 儲存進行中，請執行不關閉您的主控台。 」

### <a name="the-xbox-one-app-model-and-app-navigation"></a>Xbox One 的應用程式模型和應用程式瀏覽

Xbox One 可讓多個應用程式之間快速切換使用者。 撰寫得當的應用程式可讓使用者挑選他們離開的地方其最後一個活動期間與相關的內容載入速度快，即使使用者可存取它最後一次關閉應用程式。

Xbox One 主控台可以執行專屬的資料分割中只有一個應用程式，一次。 呈現的快速切換使用者體驗需要獨佔目前執行的應用程式，以關閉快速當使用者想要執行另一個。 當使用者嘗試切換至另一個應用程式時，系統將會使用的應用程式傳送暫止通知。 在此期間，應用程式應該儲存相關的狀態，並從其暫止函式傳回。 系統會強制執行時間上限為 1 秒，這項作業。 如果未在 1 秒內傳回應用程式，系統會強制終止應用程式。 應用程式無法阻止使用者瀏覽離開此處，如同瀏覽模型，現代的智慧型手機和平板電腦上。

另外還有其他情況下，在其中獨佔的應用程式暫停時，例如系統的輸入未閒置或低電源狀態，當使用者按下電源按鈕，在主控台上。 一旦應用程式暫停時，它可能會繼續執行系統卸載的情況下。 這可讓快速恢復功能。 要知道的重點是，也可能終止或繼續已暫停的應用程式。 應用程式永遠必須儲存狀態，以免它就會終止。

若要順利使用 Xbox One 的應用程式模型，應用程式應該準備好將狀態序列化到記憶體緩衝區中快速地使相關的狀態可以儲存在 1 秒暫停的時間範圍。

請注意，關於使用者的遊戲，儲存的資料和狀態的應用程式，例如功能表內的位置相關的資料之間的差異。 除了應用程式暫停時，請儲存的遊戲，您應該考慮保存功能表狀態，如果使用者是中間設定或自訂的主要的遊戲引擎以外的字元。

使用者可能會讓遊戲暫停很長的時間。 請考慮在長時間暫停之後繼續遊戲時提供不同的體驗。 如果使用者尚未播放兩週，而一小時中斷可能會更常見，而且保證遊戲快速恢復，則回放到他們的活動從交火戰的使用者可能會突兀和非預期的體驗。

如需 Xbox One 的應用程式模型的詳細資訊，請參閱下列資源：

-   [新式應用程式切換起居室的絨布](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx)，Xfest 2012 簡報
-   [殼層體驗](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform/xfest2013)，在 Xfest 2013 簡報
-   [處理序存留期管理 Xbox one](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)，GDN 白皮書

> [!NOTE]
> 在某些簡報[Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx)並[Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx)包含 Xbox One 支援離線播放公告因為過時的資訊。


### <a name="storage-options-on-xbox-one"></a>Xbox One 上的儲存體選項

Xbox One 提供數個儲存體選項，每個都有它自己的優點和限制。 應用程式可能需要使用多種選項，視應用程式的需求而定。


<a name="connected-storage"></a>已連接儲存體
-----------------
已連接儲存體，旨在協助應用程式儲存 Xbox One 遊戲資料和其他相關的應用程式狀態資料，應該在主控台之間漫遊。 連接儲存體 API，專用 Xbox one，可協助儲存，並將該資料上傳。 API 的運作方式與 Xbox One 的應用程式模型的組合。

連接儲存體 API 提供下列功能：

-   應用程式可以快速將儲存最多 16 MB 的資料一次在系統磁碟分割，然後在本機快取的 HDD 上，系統並上傳至雲端中的記憶體緩衝區。
- 適用於受管理的合作夥伴和ID@Xbox開發人員：
  - 256 MB 每個使用者/應用程式的雲端儲存體。
- 適用於 Xbox Live 創作者計劃開發人員：
  - 64 MB 每個使用者/應用程式的雲端儲存體。
-   電源故障強固的回應，應用程式不一定要處理與儲存的部分資料。
-   資料自動上傳至雲端，即使應用程式未執行。
-   資料可在連線到 Xbox Live 的 Xbox One 主控台。
-   Xbox Live 處理跨裝置同步處理和衝突管理而不需要應用程式的參與程度。

如需有關連接的儲存體 API 的詳細資訊，請參閱 Xbox Live SDK xblesdk.chm （其中會記載 Xbox Live 延伸模組 SDK Api） 中的適當章節。


<a name="xbox-live-title-storage"></a>Xbox Live 的標題儲存體
-----------------------
標題的儲存體服務提供下列功能的資料儲存體的跨平台 REST API:

-   提供使用者、 應用程式及各種平台之間共用的資料
-   支援二進位、 JSON 和組態檔
-   適用於受管理的合作夥伴和ID@Xbox開發人員：
    - 每個使用者/應用程式的雲端儲存體的 256 MB
    - 256 MB 的每個標題全域儲存體
- 適用於 Xbox Live 創作者計劃開發人員：
  -   每個使用者/應用程式的雲端儲存體的 64 MB
  -   256 MB 的每個標題全域儲存體

使用服務的需求：

-   Xbox One 主控台必須在線上才能存取服務
-   執行應用程式; 時，必須先完成所有的服務互動資料傳輸不會在背景自動完成。

如需詳細資訊，請參閱 < *Xbox Live 的標題儲存體*，XDK 文件中。


<a name="local-temporary-storage"></a>本機暫存儲存體
-----------------------
在主控台中，應用程式可以存取本機暫存儲存體，具有下列特性：

-   2 GB 的專用的硬碟機，可存取儲存體路徑 t\\。
-   應用程式未執行時，可能會收回此儲存體的內容。

如需有關本機儲存體的詳細資訊，請參閱 XDK 文件中的本機儲存體。


<a name="configuring-your-app-for-connected-storage"></a>設定您的應用程式連接的儲存體
------------------------------------------
當您使用連接儲存體 API 時，所有讀取和寫入作業會使用 Xbox Live 主要服務設定識別碼 (SCID)，在您的應用程式資訊清單檔案 AppXManifest.xml 中定義的關聯：

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

如需有關如何取得您的應用程式識別碼和 SCID 標題的詳細資訊，請參閱*設定註冊 Xbox Live 開發沙箱*，XDK 文件中。



## <a name="connected-storage-system-concepts"></a>連接儲存體： 系統概念

本章節描述連接的儲存體系統、 其關聯性和其適當用法的元件。

### <a name="connected-storage-space"></a>連接的儲存空間

概括而言，連接的儲存體系統中的所有資料都是相關聯的使用者或電腦 （例如，個別 Xbox One 主控台）。 特定使用者或電腦的應用程式所儲存的所有資料都會都儲存在已連線的儲存空間。

您的應用程式的每個使用者取得連接的儲存空間限制為 256 MB 的儲存體總計。 請務必請注意此儲存體，專屬於您單獨的應用程式，它將不會共用與其他應用程式。

您的應用程式會在本機連接的儲存體空間，以讓電腦中，也有 64 MB 的空間。 此儲存體空間是獨立的使用者，並可存取，即使沒有任何使用者登入。

若要取得連接的儲存空間，應用程式呼叫*ConnectedStorageSpace.GetForUserAsync 方法*或*ConnectedStorageSpace.GetForMachineAsync 方法*。 這可能長時間執行的作業，特別是如果使用者有一個裝置上儲存資料，並正在第一次在其他裝置上繼續遊戲。 如需此程序，以及可能的錯誤狀況，可能會發生於應用程式在等候取得連接的儲存空間的詳細資訊，請參閱*同步處理已連接的儲存空間*稍後這份文件。

應用程式取得後**ConnectedStorageSpace**下方的所有方法呼叫的物件， *Windows.Storage 命名空間*物件或從中衍生其他物件不會相依於回應的使用從 web 服務，以完成。 不過，因為找不到專為使用中的應用程式的存取權 Xbox 一個 HDD，無法保證嚴格的上限這些方法的效能。


### <a name="connected-storage-containers-and-blobs"></a>連接儲存體： 容器和 blob

*連接的儲存體容器*，或*容器*簡稱為儲存體的基本單位。 每個已連接的儲存空間可以包含多個容器，如下圖所示。

**圖 1。  連接的儲存空間 （每個標題/電腦或每個標題/使用者）**

![](../../images/connected_storage/connected_storage_space_containers.png) 資料會儲存在容器做為其中一個或多個緩衝區呼叫*blob*。 下圖說明在磁碟上的容器的內部系統表示法。 針對每個容器中，沒有容器檔案，其中包含每個 blob 容器中的資料檔案的參考。

**圖 2。  容器的圖表**

![](../../images/connected_storage/container_storage_blobs.png)

若要將資料儲存在容器中，呼叫*ConnectedStorageContainer.SubmitUpdatesAsync 方法*，提供名稱和 blob （緩衝區物件） 的對應。 中所述的所有變更**SubmitUpdatesAsync**呼叫會以不可分割方式套用，也就是以所有 blob 會都更新要求，或整個作業將會終止或容器會保留在其之前呼叫的狀態。

個別儲存使用的作業**SubmitUpdatesAsync**一次會限制為 16 MB 的資料。


### <a name="submitupdatesasync-behavior"></a>SubmitUpdatesAsync 行為

當**SubmitUpdatesAsync**是呼叫，呼叫所提供的緩衝區會快速複製從應用程式的資料分割到專用的記憶體空間，在系統磁碟分割。 已成功複製記憶體到系統磁碟分割上，一旦完成處理常式中提供**SubmitUpdatesAsync**應用程式，應用程式表示它安全地釋放它所配置的記憶體內叫用呼叫在本機的資料。

然後，系統會將 blob 儲存至主控台的硬碟機，並完成該作業，並認可該容器在整個作業的最後一個容器更新。

16 MB 上限，在記憶體中沒有共用的資料分割來接收**SubmitUpdatesAsync**資料。 如果呼叫**SubmitUpdatesAsync**無法立即服務由系統因為專用 16 MB 的緩衝區，在可用記憶體不足，無法呼叫已排入佇列服務。 系統持續傳送資料從 16 MB 的緩衝區到硬碟，並已排入佇列的更新服務在空間變成可用 16 MB 的緩衝區中，它們所要求的順序。

**圖 3。  SubmitUpdatesAsync 行為**

![](../../images/connected_storage/submitupdatesasync_behavior.png) 上傳至雲端發生類似的方式：個別的 blob 上傳至服務，並更新作業認可的最後一個更新參考其他上傳的 blob 的容器檔案。 在上傳到雲端，這項合併成單一也是最後一個更新可確保中參考的所有資料**SubmitUpdatesAsync**呼叫可能會認可整個或容器會保持不變。 如此一來，即使在系統離線或電源中斷期間上傳作業，使用者可以移至另一個 Xbox One 的主控台，，請從雲端下載資料，並繼續玩所有容器的一致檢視。

> [!IMPORTANT]
> 整個容器的資料相依性不是安全的。  個別結果*SubmitUpdatesAsync*呼叫一定要完全，或完全不套用。

**SubmitUpdatesAsync**呼叫必須假設未來**SubmitUpdatesAsync**會成功地完成呼叫，以將容器保留的有效狀態。 換句話說，應用程式不能依賴多個**SubmitUpdatesAsync**將所有必要的資料儲存至容器的呼叫。 每個**SubmitUpdatesAsync**呼叫必須維持有效狀態的應用程式，稍後再閱讀，指定容器的內容。

為了說明這個問題，假設其中一個容器會追蹤金級和字元，名為 Bob 所持有的食物的數量。 標題可以儲存兩個 blob，名為*食物*並*金級*。 Bob 金級 100 和開始沒有食物他清查中。

**圖 4。  範例案例：Bob 開始 100 金級。**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

現在 Bob 會花費 50 金級。 標題會準備**SubmitUpdatesAsync**呼叫，這會更新金級 blob 的值為 50。

系統會擷取更新的 blob 和容器更新至更新的緩衝區的資訊。 然後系統會將新的 blob 的值複製到硬碟機。

**圖 5。  系統會擷取更新的資訊，並將值複製到硬碟機。**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

最後，系統會更新容器檔案，以參考新的 blob HDD 上。 最後，系統會在記憶體回收作業中移除未參考的 blob。

**圖 6。  系統更新的 HDD 上的容器檔案，並移除未參考的 blob。**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

請注意，多個 blob 您使用每個**SubmitUpdatesAsync**呼叫時，更多的時間，才能完成強行儲存資料的檔案系統作業所需的不可部分完成作業。 在上述範例中的資料儲存體的資料粒度是太小，但它要清楚地說明一個容器中的多個 blob 的不可部分完成的更新行為。


### <a name="updating-multiple-blobs--the-wrong-way"></a>更新多個 blob-錯誤的方式

假設 Bob 要買一些食物。 為了簡單起見，我們會假設 1 個單位的黃金購買 1 個單位的食物，，和 Bob 想要購買的食物的 25 個單位。 應用程式可能會發出一**SubmitUpdatesAsync**將 25 個單位的食物，然後另一個来減去的黃金從 Bob 的 25 個單位的呼叫\_清查容器。 不過，即使兩個已完成的處理常式**SubmitUpdatesAsync**呼叫呼叫，則可能不正確的結果，因為事件，例如電源中斷，可能會停止寫入硬碟機的資料，或不完整的同步處理至雲端。 下圖說明系統，以及在電源中斷，在任何一個步驟的結果所採取的步驟。

假設兩個資料**SubmitUpdatesAsync**呼叫已在系統的更新緩衝區，並已叫用項目的兩個呼叫的完成處理常式。

首先，系統會將食物 blob 的新值的資料寫入磁碟中。

**圖 7。  系統會將食物 blob 值寫入磁碟。**

![](../../images/connected_storage/update_method_wrong_way_1.png) 接下來，系統會更新容器以參考新寫入的值。 下圖所示，如果在此步驟之後，以及之前的下一個電源已刪除，Bob 會得到更多心力，而不需要對應的金級扣除他清查取得 25 食物。

**圖 8。  系統更新的容器，以參考新寫入的值。**

![](../../images/connected_storage/update_method_wrong_way_2.png)

接下來，系統會將新值的金級的 blob 資料寫入磁碟中。 值為 Bob 所參考的金級\_清查容器仍未更新，且 Bob 25 詳細金級比他應該 — 但我們很快就能想要的結果。

**圖 9。  系統會將新值的金級的 blob 資料寫入磁碟。**

![](../../images/connected_storage/update_method_wrong_way_3.png)

最後，系統會更新以參考為新寫入的 blob 容器檔案，所要的結果。

**圖 10。  系統更新來參考新寫入的金級 blob 容器檔案。**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a>更新多個 blob，以正確的方式

若要確保以不可分割方式更新金級和食物 Bob 的庫存數量，而不會因電源中斷，而不正確的中繼狀態的正確方法是更新這兩個在單一的 blob **SubmitUpdatesAsync**呼叫。 然後，系統將會採取下列步驟。

首先，系統會將食物 blob 的新值的資料寫入磁碟中。

**圖 11。  系統寫入食物 blob 的新值的資料。**

![](../../images/connected_storage/update_method_right_way_1.png) 然後系統會將新值的金級的 blob 資料寫入磁碟中。

**圖 12。  金級 blob 的新值的資料寫入系統。**

![](../../images/connected_storage/update_method_right_way_2.png) 最後，系統會更新參考這兩個新的 blob 容器檔案。

**圖 13。  系統更新來參考這兩個新的 blob 容器檔案。**

![](../../images/connected_storage/update_method_right_way_3.png) 雖然此範例中是非常簡單，它會說明必須套用以不可分割方式發出單一容器中進行所有修改資料的重要性**SubmitUpdatesAsync**呼叫所需的所有更新。 透過這種方式購買與金級食物的情況下，應用程式可避免潛在的競爭條件，可能不正確地更新其中一個值有太多黃金保留字元。

### <a name="performance-characteristics-and-considerations"></a>效能特性和考量

16 MB 的更新緩衝區，在共用的資料分割允許限定的數量的非常快速地執行更新作業。 在系統可以將資料保存到磁碟的速度取決於緩衝區中的資料量和 blob 的數目。 因為每個 blob 寫入磁碟恢復功能方面，較大的緩衝區中的 blob 數目時，需花費的時間將它們保存到磁碟。

[圖 13] 顯示範例的處理時間**SubmitUpdatesAsync**作業使用兩個 512 k blob 更新每 2 秒，另一個系統上沒有其他的硬碟機活動時，1024 k blob 更新。 系統可以在穩定狀態下，處理每個更新 14-18ms年內運作。

**圖 14。  處理時間 SubmitUpdatesAsync 作業使用兩個 512 k blob 更新每 2 秒，另一個 1024 k blob 更新與其他的硬碟機活動。**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png) [圖 14] 顯示三個的處理時間 1024 k blob 以各種不同的時間間隔。

系統可以處理這些更新 87ms年穩定狀態下在 3 秒的間隔。 增加一次每 2 秒的頻率，系統仍然可以處理 87ms年穩定狀態中的更新。

減少為 1 秒更新之間的間隔，改變的穩定狀態行為。 系統可以處理在每個更新，87ms年 60 更新，但除此之外，每個更新所需的明顯更久，達到穩定狀態的處理時間更新時，以大幅波動的第二個每 500 毫秒。 這是因為 16 MB 記憶體緩衝區填入速度比它可以將資料排清至磁碟; 快更新會被迫等候先前的更新可寫入。

更新一個更新每 0.5 秒間隔時，會大幅增加效果。 系統可以重新處理此間隔的只有 7 更新，在每個更新，才會到達穩定狀態下在其中每個更新時間為超過 1 秒，以處理極高的變化 87ms年。

**圖 15。  處理時間的三個 1024 k blob 以各種不同的時間間隔。**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png) 這些說明僅為範例。 您的應用程式通常應該不會把資料儲存此情況下，但它也不會正式運作在環境中可用的磁碟 I/O。

請務必了解這些範例為基礎系統的特性，來測量在各種運作狀況，如此可確保您儲存在小於 1 秒期間您的應用程式內完成作業的應用程式的暫止處理常式。


## <a name="synchronizing-a-connected-storage-space"></a>同步處理已連接的儲存空間

-   連線能力檢查
-   取得鎖定
-   容器清單、 比較及合併邏輯
-   容器下載

當您的應用程式要求存取連接的儲存空間時，系統就會執行同步處理程序將使用者的已儲存的資料一致的狀態，在 Xbox One 的主控台，並讓他或她的資料可用於離線播放。 因為同步處理花費的時間長短，而且可能會要求使用者做出決策，系統可能會在程序的各個階段就向使用者顯示 UI。

使用者可以離開您的應用程式，也可以隨時按下 Xbox 按鈕即使 UI 是使用同步處理。 系統會隱藏 UI，並同步處理繼續進行，就可以不需使用者互動。 當使用者巡覽回到應用程式時，UI 會在同步處理完成之後，除非再次顯示。 系統永遠不會讓使用者選取的相關假設，隱藏 UI 時。

當使用者是在 [首頁] 畫面中，而您的應用程式轉譯是仍在大型的應用程式磚中顯示時，系統就會不顯示任何 UI 的同步處理，因為很重要的應用程式，使符合當前的視覺效果時**GetForUserAsync**呼叫完成。 此應用程式仍然可互動，而正在等候載入的資料，可向使用者指出一直持續不斷地的轉譯。

下圖概述高階應用程式要求連接的儲存空間時，系統將會依照的順序。 如果整個序列會超過幾秒鐘的時間，就會顯示系統繪製的同步處理 UI。

**圖 16。  應用程式要求連接的儲存空間時，系統所遵循的順序。**

![](../../images/connected_storage/app_requests_connected_storage_space.png) 該服務時，系統會透過下列階段**GetForUserAsync**要求：

-   連線能力檢查
-   取得鎖定
-   容器清單、 比較及合併邏輯
-   容器下載

### <a name="connectivity-check"></a>連線能力檢查

若要啟動服務**GetForUserAsync**要求時，系統會檢查連線。 如果主控台已離線，整個同步處理程序會略過，並指定使用者連接的儲存空間會標示為離線，目前工作階段。 任何資料修改將會與雲端儲存體協調下次您的應用程式存取相同的使用者連接的儲存空間，系統可以連線到標題的儲存體服務。 以往，沒有 UI 會顯示在此情況下。

連接的儲存體的內容之外的離線處理的相關資訊，請參閱*Xbox 一個標題的服務中斷復原*。

### <a name="lock-acquisition"></a>取得鎖定

確認連線能力之後, 系統會嘗試取得獨佔存取權與您的應用程式和目前的使用者相關聯的雲端儲存空間。 這被透過將鎖定檔案放在您的標題儲存體連接的儲存體區域。 如果主控台已上線、 可以取用服務，能夠在短時間內取得鎖定，而且沒有 UI，會出現，並同步處理程序會繼續。

一旦系統已取得鎖定，以針對特定連接的儲存空間，並傳回應用程式連接的儲存空間的執行個體，沒有任何應用程式的 API 呼叫中的資料作業成功的 web 要求就會封鎖連接的儲存空間。 鎖定會提供足夠的保護，以便即使使用者拔除網路纜線從系統之後您的應用程式已取得連接的儲存空間,，會根據可用的本機資料的 API 呼叫。

在鎖定擷取步驟期間，有幾個可能的錯誤案例：

 **同步處理 UI**如果主控台已上線，但已不會取得從服務短時間內鎖定，就會顯示 「 同步處理 」 的 UI。

 **重大鎖定**如果使用者已在另一個主控台上播放應用程式，因為他或她上次播放上目前的很可能在其他主控台對儲存體空間的獨佔存取，而且正在進行將資料上傳。 它也是可能已開始將資料上傳另一個主控台，但已經失去其連接或電源之前完成。

上述兩種情況稱為*鎖定爭用*，在任一情況下，系統會顯示 UI，以說明另一個主控台上傳資料。 使用者可以等候此程序完成，或使用雲端中目前可用的資料。 如果使用者選擇要使用的雲端資料，系統會取得鎖定本身 （中斷鎖定），取得獨佔存取權的雲端儲存體，使用者和應用程式。 從其他主控台上的傳已取消，並繼續進行同步處理程序。

### <a name="container-listing-comparison-and-merger-logic"></a>容器清單、 比較及合併邏輯

之後取得鎖定，系統會要求在雲端，以指定應用程式和使用者的所有容器的清單。 然後比較使用雲端中的資料在本機硬碟機的內容，並根據比較結果來繼續進行：

 **本機資料比對雲端**如果不已有其他主控台，從任何變更，而且資料在雲端和本機固定磁碟機是完全相同，則同步處理完成，完成處理常式的**GetForUserAsync**在此階段中，叫用呼叫，所以您的應用程式可以繼續與載入和儲存。

 **任何本機資料**如果雲端資料，但本機主控台不具有任何，來自雲端的資料會下載到本機。 這可能是，比方說，當使用者第一次，在播放在朋友的房子。

 **修改本機和雲端中的相同容器**如果使用者已修改另一個主控台上播放在雲端中的容器，並已修改的同一個容器，離線使用目前的主控台時，無法自動合併資料。 將會要求使用者選擇要保留的資料。 發生衝突，使用者可以選擇取代原則：永遠保持在本機的資料或雲端資料，或使用者可以選取**取消**延遲進行選擇。 如果使用者選擇的雲端 」 或 「 本機資料作為取代原則，具有相同名稱的容器，但使用不同的內容 — 就會據以解析。

如果使用者選取**取消**，標題就可以存取儲存系統處於非解決狀態，如同使用者進行過離線。 在此情況下，解決衝突的 UI 會顯示一次應用程式要求存取權已連接的儲存空間，在下一次，如果主控台在線上。

### <a name="container-download"></a>容器下載

任何衝突已解決之後，系統就會有以識別哪些容器需要從雲端下載所需的所有資訊。 會下載所有必要的容器，完成處理常式*ConnectedStorageSpace.GetForUserAsync 方法*在這個階段中，將會叫用，所以您的應用程式可以繼續與載入和儲存。

在此步驟中一些可能的錯誤：

**沒有足夠的本機儲存體**  
如果沒有足夠的本機硬碟機空間，以讓必要的容器，會向使用者顯示 UI 要求他們以釋放磁碟空間，藉由移除本機儲存的資料。 為了避免不會備份在雲端中的重要資料將永久刪除它們，UI 清楚指出是只要本機快取的資料和對目前的主控台是唯一的資料。

當 UI 會向使用者顯示：

-   如果使用者釋放足夠的空間，同步處理會繼續，並完成。
-   如果使用者取消卻未釋放足夠的空間，完成處理常式的 UI **GetForUserAsync**呼叫會傳回**OutOfLocalStorage**— 請參閱*ConnectedStorageErrorStatus列舉型別*。 應用程式應該確認使用者想要播放而無法儲存資料。 如果使用者同意，應用程式應該繼續而不儲存該使用者的資料。 如果使用者指出他或她想要將資料儲存在播放時，應用程式應該重複**GetForUserAsync**呼叫，這會顯示 UI，以釋出空間。

**使用者取消同步處理**  
如果使用者不想等候同步處理完成，並取消選取，會通知使用者，不是所有已儲存的資料將會提供。 完成處理常式**GetForUserAsync**會叫用呼叫，在此階段中，並應用程式可以繼續進行載入和儲存。

**網路逾時**  
如果資料下載逾時，由於網路連線或服務可用性問題，則使用者可以重試一次同步處理的選項。 如果他或她選擇不，會通知使用者，不是所有已儲存的資料將會提供。 完成處理常式**GetForUserAsync**會叫用呼叫，在此階段中，並應用程式可以繼續進行載入和儲存。

## <a name="development-tools"></a>開發工具

這兩種工具可協助您開發您的應用程式使用連接的儲存體：XbStorage，Fiddler。

### <a name="managing-connected-storage-with-xbstorage"></a>管理已連接的儲存體與 XbStorage

XbStorage 是一種開發工具，可從開發電腦管理 Xbox One 的開發套件上的本機連接的儲存體資料。

此工具可讓清除從硬碟中，本機連接的儲存體空間，以及匯入和匯出個別使用者或機器-連線儲存空間藉由使用 XML 檔案。

本機連接的儲存空間上執行作業時，系統會就如同應用程式本身必須已執行該作業。 與之前複製雲端可能已連接的儲存空間的資料複製到本機檔案會同步處理。

同樣地，從開發電腦上的 XML 檔案複製資料到連接的儲存體容器上的 Xbox One 的開發人員套件會導致，主控台將會開始將該資料上傳至雲端。 以下情況除外： 如果開發人員套件無法取得鎖定，或在主控台上的容器與雲端之間沒有衝突。 在此情況下，主控台就會當做使用者決定不是用來解決衝突-例如，藉由挑選要保留之容器的一個版本-和主控台的行為就如同它已播放離線標題已啟動的下一次。

XbStorage 的重設命令會清除所有 SCIDs' 和使用者的已儲存的資料的本機儲存體，但不會改變儲存在雲端中的資料。 這是適用於設定主控台，它會在使用者如果已漫遊至主控台，並從時播放標題雲端下載資料的狀態。

如需 XbStorage 的詳細資訊，請參閱*管理連接儲存體 (xbstorage.exe)*，XDK 文件中。

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a>監視連接的儲存體使用 Fiddler 的網路活動

它可以是有助於判斷您的主控台是否要執行雲端儲存體作業時與服務互動。 使用 Fiddler，有助於判斷您的主控台正在呼叫服務成功還是發生授權錯誤。 Xbox One 上設定 Fiddler 的相關資訊，請參閱*如何使用 Fiddler 與 Xbox One*，此 XDK 文件中。

## <a name="resources"></a>資源

除了上述建議的資源，以下條件可能會很有幫助開發您的應用程式或標題：

-   XDK 文件中已連接儲存體概觀
-   [處理序存留期管理](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform/aug2013xdk_qfe5/samples)，可從範例遊戲開發人員網路 (GDN) 上的範例
-   [「 處理序的 Xbox One 的生命週期管理 (PLM) 」](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)，白皮書可從 GDN 白皮書
