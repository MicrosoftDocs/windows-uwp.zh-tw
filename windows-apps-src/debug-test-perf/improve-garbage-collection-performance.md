---
author: jwmsft
ms.assetid: F912161D-3767-4F35-88C0-E1ECDED692A2
title: 改善記憶體回收效能
description: 使用 C# 和 Visual Basic 撰寫的通用 Windows 平台 (UWP) app 會從 .NET 記憶體回收行程自動管理記憶體。 本節摘要說明 UWP 應用程式中的 .NET 記憶體回收行程的行為和效能最佳做法。
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 31279de84b8f00e4489a7aae962caa231bb16dc1
ms.sourcegitcommit: ca96031debe1e76d4501621a7680079244ef1c60
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/30/2018
ms.locfileid: "5812535"
---
# <a name="improve-garbage-collection-performance"></a>改善記憶體回收效能


使用 C# 和 Visual Basic 撰寫的通用 Windows 平台 (UWP) app 會從 .NET 記憶體回收行程自動管理記憶體。 本節摘要說明 UWP app 中的 .NET 記憶體回收行程的行為和效能最佳做法。 如需 .NET 記憶體回收行程如何運作，以及用於偵錯和分析記憶體回收行程效能之工具的詳細資訊，請參閱[記憶體回收](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx)。

**注意：** 需要介入記憶體回收行程的預設行為是一般的記憶體問題與您的應用程式的強式指標。 如需詳細資訊，請參閱[在 Visual Studio 2015 偵錯時的記憶體使用量工具](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx)。 本主題僅適用於 C# 和 Visual Basic。

 

記憶體回收行程會藉由平衡 Managed 堆積的記憶體消耗量與記憶體回收所需執行的工作量，來判斷何時執行。 記憶體回收行程執行這個動作的其中一個方法是將堆積區分成不同世代，而且大部分時間只回收部分堆積。 Managed 堆積中有三個世代：

-   世代 0。 這個世代包含小於 85KB 的新配置物件，超過這個大小的部分屬於大型物件堆積。 大型物件堆積是在世代 2 回收進行回收。 世代 0 回收是最常出現的回收類型，而且會清除短期物件，例如區域變數。
-   世代 1。 這個世代包含世代 0 回收存留的物件。 它會做為世代 0 和世代 2 之間的緩衝。 世代 1 回收的發生頻率少於世代 0 回收，而且會清除之前世代 0 回收期間作用中的暫存物件。 世代 1 回收也會回收世代 0。
-   世代 2。 這個世代包含世代 0 和世代 1 回收存留的長期物件。 世代 2 回收最少發生且會回收整個 Managed 堆積，包括大型物件堆積 (包含超過 85KB 的物件)。

您可以從兩方面測量記憶體回收器的效能：執行記憶體回收所需的時間以及 Managed 堆積的記憶體消耗。 如果您的 app 是堆積大小不超過 100MB 的小型 app，請將重點放在減少記憶體消耗。 如果您的 app 擁有大於 100MB 的 Managed 堆積，則僅將重點放在縮短記憶體回收的時間。 以下說明如何協助 .NET 記憶體回收器獲得較佳的效能。

## <a name="reduce-memory-consumption"></a>減少記憶體消耗

### <a name="release-references"></a>釋放參考

參考 app 中的物件時，將無法回收該物件及其所參考的所有物件。 .NET 編譯器非常適合用來偵測變數何時不再使用，這樣便可收集該變數所保有的物件。 但是有些情況下，某些物件參考其他物件並不明顯，因為部分物件圖形可能是您的 app 所使用的程式庫所擁有。 若要了解找出哪些物件存留在某個記憶體回收的工具和技術，請參閱[記憶體回收和效能](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx)。

### <a name="induce-a-garbage-collection-if-its-useful"></a>有效時引發記憶體回收

只在已測量應用程式效能而且確定引發回收可以改善其效能時，才引發記憶體回收。

您可以透過呼叫 [**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx) 引發世代的記憶體回收，其中 n 是您要回收的世代 (0、1 或 2)。

**注意：** 建議您，您不用強制記憶體回收集合中您的應用程式因為記憶體回收行程使用許多啟發學習法來判斷執行回收的最佳時間，以及回收會造成在許多情況下使用不必要的 cpu。 但如果您知道 app 中有大量不再使用的物件，而且希望將這個記憶體還給系統，此時就適合強制記憶體回收。 例如，您可以在載入遊戲的最後階段引發回收，以便在遊戲開始前釋放記憶體。
 
若要避免不慎引發太多記憶體回收，可以將 [**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) 設為 **Optimized**。 這樣會指示記憶體回收行程只在確定回收效能夠高時，才開始回收。

## <a name="reduce-garbage-collection-time"></a>縮短記憶體回收時間

如果您分析 app 後發現記憶體回收時間很長，請閱讀本節。 記憶體回收相關的暫停時間包括：執行單一記憶體回收階段所經過的時間，以及 app 執行記憶體回收所花費的總時間。 執行回收所需的時間取決於回收器必須分析的即時資料量。 世代 0 和世代 1 的大小有限制，但世代 2 會隨著 app 內使用中的長期物件增加而不斷成長。 這表示世代 0 和世代 1 的回收時間有所限制，而世代 2 回收可能需要較長的時間。 記憶體回收的執行頻率大部分取決於您所配置的記憶體，因為記憶體回收會釋放記憶體，以滿足配置要求。

記憶體回收行程偶爾會暫停您的應用程式以執行工作，但不需要在執行回收的整段時間暫停您的應用程式。 使用者通常不會感覺到應用程式中的暫停時間，尤其是在世代 0 和世代 1 回收。 .NET 記憶體回收行程的[背景記憶體回收](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection)功能可同時執行應用程式與世代 2 回收，而且只會暫停應用程式一段很短的時間。 但是並不一定可以同時執行世代 2 回收和背景回收。 在這種情況下，如果您有夠大的堆積 (大於 100MB)，使用者就可能感受到暫停。

經常進行記憶體回收會造成 CPU 消耗量增加 (也更耗電)、較長的載入時間，或降低應用程式的畫面播放速率。 以下的一些技術可以用來縮短記憶體回收時間和 Managed UWP app 中與回收相關的暫停。

### <a name="reduce-memory-allocations"></a>減少記憶體配置

如果您沒有配置任何物件，除非系統發生記憶體不足的狀態，否則不會執行記憶體回收行程。 減少您所配置的記憶體數量可以直接轉化為較少的記憶體回收頻率。

如果完全不想在某些應用程式區段暫停，您可以提前在效能比較不重要的期間，預先配置必要的物件。 例如，遊戲可能會在載入關卡畫面期間配置遊戲需要的所有物件，但在遊戲進行期間不做任何配置。 這可以避免使用者玩遊戲時發生暫停，而且可以得到更一致的高畫面播放速率。

### <a name="reduce-generation-2-collections-by-avoiding-objects-with-a-medium-length-lifetime"></a>避免中存留期的物件，就可以減少世代 2 回收

當您的應用程式中有非常短期和/或非常長期的物件時，世代的記憶體回收效果最好。 短期物件會在較不耗費資源的世代 0 和世代 1 回收中進行回收，長期物件則提升至世代 2，這是比較不常執行的回收。 長期物件是整個應用程式期間都會用到的物件，或是在應用程式某段重要期間 (例如特定頁面或遊戲關卡) 使用的物件。

如果您經常建立暫時存在的物件，但存留期足以提升至世代 2，則會進行更耗費資源的世代 2 回收。 您可以重複使用現有的物件，或更快速地釋放物件，以減少世代 2 回收。

在使用者捲動的清單中用來顯示項目的物件，就是存留期適中的常見物件。 如果物件是在清單中的項目捲動進入檢視時建立，而在清單中的項目捲出檢視時便不再參考該物件，則通常您的應用程式就會有大量的世代 2 回收。 在這種情況下，您可以預先配置並重複使用一組物件，用於主動顯示給使用者的資料，然後在清單中的項目進入檢視時使用短期物件載入資訊。

### <a name="reduce-generation-2-collections-by-avoiding-large-sized-objects-with-short-lifetimes"></a>避免使用存留期短的大型物件，就可以減少世代 2 回收

超過 85KB 的物件會配置在大型物件堆積 (LOH)，並於世代 2 中回收。 如果您有大於 85KB 的暫時變數 (例如緩衝區)，則世代 2 回收會清除它們。 將暫時變數限制為小於 85KB，可減少 app 中的世代 2 回收次數。 常用的一種技巧是建立緩衝區集區，然後重複使用集區中的物件，以避免大量暫時配置。

### <a name="avoid-reference-rich-objects"></a>避免太多參考的物件

記憶體回收行程會依照物件之間 (從應用程式的根目錄開始)的參考，判斷哪些物件為作用中。 如需詳細資訊，請參閱[記憶體回收期間執行的動作](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection)。 如果物件包含許多參考，記憶體回收行程就需要執行較多的動作。 一個常見的技術 (通常用於大型物件) 是將大量參考的物件轉換為沒有參考的物件 (例如，不儲存參考，改為儲存索引)。 當然，這個技術只適用於邏輯上可以這麼做的物件。

以索引取代物件參考對您的應用程式來說會是一個具破壞性且複雜的變更，但是這種做法對於含有大量參考的大型物件非常有效。 請只在您發現應用程式中的大量記憶體回收與大量參考的物件有關時，才執行這個作業。

 

 




